'use strict';

var react = require('react');
var jsxRuntime = require('react/jsx-runtime');
var flowClient = require('@speechmatics/flow-client');

const FlowContext = react.createContext(null);

function useFlow() {
  const context = react.useContext(FlowContext);
  if (context === null) {
    throw new Error("Flow client uninitialized in context");
  }
  const { client, sessionId, socketState } = context;
  const startConversation = react.useCallback(
    (jwt, {
      config,
      audioFormat
    }) => client.startConversation(jwt, { config, audioFormat }),
    [client]
  );
  const endConversation = react.useCallback(() => client.endConversation(), [client]);
  const sendAudio = react.useCallback(
    (pcm16Data) => client.sendAudio(pcm16Data),
    [client]
  );
  return react.useMemo(
    () => ({
      startConversation,
      endConversation,
      sendAudio,
      socketState,
      sessionId
    }),
    [startConversation, endConversation, sendAudio, socketState, sessionId]
  );
}

function useFlowEventListener(message, cb) {
  const context = react.useContext(FlowContext);
  if (context === null) {
    throw new Error("Flow client uninitialized in context");
  }
  return useClientEventListener(context.client, message, cb);
}
function useClientEventListener(client, eventType, cb) {
  return react.useEffect(() => {
    client.addEventListener(eventType, cb);
    return () => client?.removeEventListener(eventType, cb);
  }, [client, eventType, cb]);
}

function FlowProvider({
  server,
  children,
  ...options
}) {
  const [client] = react.useState(() => {
    return new flowClient.FlowClient(server ?? "wss://flow.api.speechmatics.com", options);
  });
  const socketState = useClientSocketState(client);
  const [sessionId, setSessionId] = react.useState();
  useClientEventListener(client, "message", ({ data }) => {
    if (data.message === "Error") {
      console.error(data);
    } else if (data.message === "ConversationStarted") {
      setSessionId(data.asr_session_id);
    }
  });
  useClientEventListener(client, "socketClose", () => {
    setSessionId(void 0);
  });
  const value = react.useMemo(
    () => ({
      client,
      socketState,
      sessionId
    }),
    [client, socketState, sessionId]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(FlowContext.Provider, { value, children });
}
const SOCKET_EVENTS = [
  "socketInitialized",
  "socketOpen",
  "socketClosing",
  "socketClose",
  "socketError"
];
function useClientSocketState(client) {
  const subscribe = (onChange) => {
    for (const e of SOCKET_EVENTS) {
      client.addEventListener(e, onChange);
    }
    return () => {
      for (const e of SOCKET_EVENTS) {
        client.removeEventListener(e, onChange);
      }
    };
  };
  const getSnapshot = () => client.socketState;
  return react.useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}

exports.FlowContext = FlowContext;
exports.FlowProvider = FlowProvider;
exports.useClientEventListener = useClientEventListener;
exports.useFlow = useFlow;
exports.useFlowEventListener = useFlowEventListener;
Object.keys(flowClient).forEach(function (k) {
  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return flowClient[k]; }
  });
});
//# sourceMappingURL=index.cjs.map
