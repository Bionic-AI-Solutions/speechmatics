'use strict';

var typescriptEventTarget = require('typescript-event-target');
var flowClientReact = require('@speechmatics/flow-client-react');
var react = require('react');

class TranscriptUpdateEvent extends Event {
  constructor(transcriptGroups, eventInitDict) {
    super("update", eventInitDict);
    this.transcriptGroups = transcriptGroups;
  }
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class TranscriptManager extends typescriptEventTarget.TypedEventTarget {
  constructor() {
    super(...arguments);
    // Store final transcribed words
    __publicField(this, "finals", []);
    // Store partial (in-progress) transcribed words
    __publicField(this, "partials", []);
    // Store AI agent responses
    __publicField(this, "agentResponses", []);
  }
  /**
   * Clears all transcript data and notifies listeners
   */
  clearTranscripts() {
    this.finals = [];
    this.partials = [];
    this.agentResponses = [];
    this.notifyUpdate();
  }
  /**
   * Main entry point for processing incoming messages
   * Routes different message types to their appropriate handlers
   */
  handleMessage(message) {
    switch (message.message) {
      case "AddPartialTranscript":
      case "AddTranscript":
      case "ResponseStarted":
      case "ResponseCompleted":
      case "ResponseInterrupted":
        this.processMessage(message);
        break;
      // Ignore other message types
      default:
        return;
    }
  }
  processMessage(message) {
    switch (message.message) {
      case "AddPartialTranscript":
        this.handlePartialTranscript(message);
        break;
      case "AddTranscript":
        this.handleTranscript(message);
        break;
      case "ResponseStarted":
        this.handleAgentResponseStart(message);
        break;
      case "ResponseCompleted":
      case "ResponseInterrupted":
        this.handleAgentResponseEnd(message);
        break;
    }
  }
  /**
   * Processes partial transcripts (in-progress speech)
   * These are temporary and will be replaced by final transcripts
   */
  handlePartialTranscript(message) {
    if (!message.results?.length) return;
    this.partials = this.getWords(message);
    this.notifyUpdate();
  }
  /**
   * Processes final transcripts
   * Also handles cleanup of related partial transcripts
   */
  handleTranscript(message) {
    if (!message.results?.length) return;
    const incomingWords = this.getWords(message);
    this.finals = [...this.finals, ...incomingWords];
    const resultsEndAt = incomingWords[incomingWords.length - 1].endTime;
    this.partials = this.partials.filter(
      (p) => p.startTime >= resultsEndAt && p.endTime > resultsEndAt
    );
    if (this.partials.length && message.results[0].is_eos && this.partials[0].punctuation && this.partials[0].eos) {
      this.partials.shift();
    }
    this.notifyUpdate();
  }
  /**
   * Handles the start of an AI agent response
   * Creates a new agent response entry with start time
   */
  handleAgentResponseStart(message) {
    if (!message.content || !message.start_time) return;
    this.agentResponses.push({
      speaker: "agent",
      agent: true,
      startTime: message.start_time,
      text: message.content
    });
    this.notifyUpdate();
  }
  /**
   * Handles the completion or interruption of an AI agent response
   * Updates the existing response or creates a new one if not found
   */
  handleAgentResponseEnd(message) {
    if (!message.content || !message.start_time || !message.end_time) return;
    const existingIndex = this.agentResponses.findIndex(
      (r) => r.startTime === message.start_time
    );
    const updatedResponse = {
      speaker: "agent",
      agent: true,
      startTime: message.start_time,
      endTime: message.end_time,
      text: message.content
    };
    if (existingIndex !== -1) {
      this.agentResponses[existingIndex] = updatedResponse;
    } else {
      this.agentResponses.push(updatedResponse);
    }
    this.notifyUpdate();
  }
  /**
   * Converts raw message results into Word objects
   * Handles both regular words and punctuation
   */
  getWords(message) {
    if (!message.results) return [];
    return message.results.map((r) => {
      const word = {
        startTime: r.start_time,
        endTime: r.end_time,
        text: r.alternatives?.[0]?.content ?? "",
        speaker: r.alternatives?.[0]?.speaker ?? "UU",
        // UU = Unknown User
        partial: message.message === "AddPartialTranscript"
      };
      if (r.type === "punctuation") {
        return {
          ...word,
          punctuation: true,
          eos: r.is_eos ?? false,
          attachesTo: r.attaches_to
        };
      }
      return { ...word, punctuation: false };
    });
  }
  /**
   * Generates the current state of the transcript
   * Groups words and responses by speaker and chronological order
   */
  getTranscriptGroups() {
    const sentences = this.getSentences();
    const sentencesAndResponses = [...sentences, ...this.agentResponses];
    sentencesAndResponses.sort((a, b) => {
      const startTimeA = "agent" in a ? a.startTime : a[0].startTime;
      const startTimeB = "agent" in b ? b.startTime : b[0].startTime;
      return startTimeA - startTimeB;
    });
    const allSorted = sentencesAndResponses.flat();
    const groups = [];
    let currentGroup;
    for (const wordOrResponse of allSorted) {
      if (!currentGroup) {
        currentGroup = "agent" in wordOrResponse ? {
          type: "agent",
          data: [wordOrResponse]
        } : {
          type: "speaker",
          data: [wordOrResponse],
          speaker: wordOrResponse.speaker
        };
        continue;
      }
      if (currentGroup.type === "agent" && "agent" in wordOrResponse) {
        currentGroup.data.push(wordOrResponse);
      } else if (currentGroup.type === "speaker" && !("agent" in wordOrResponse) && wordOrResponse.speaker === currentGroup.speaker) {
        currentGroup.data.push(wordOrResponse);
      } else {
        groups.push(currentGroup);
        currentGroup = "agent" in wordOrResponse ? { type: "agent", data: [wordOrResponse] } : {
          type: "speaker",
          data: [wordOrResponse],
          speaker: wordOrResponse.speaker
        };
      }
    }
    if (currentGroup) {
      groups.push(currentGroup);
    }
    return groups;
  }
  /**
   * Groups words into sentences based on punctuation and end-of-sentence markers
   */
  getSentences() {
    const sentences = [];
    let currentSentence = [];
    for (const word of [...this.finals, ...this.partials]) {
      currentSentence.push(word);
      if (word.punctuation && word.eos) {
        sentences.push(currentSentence);
        currentSentence = [];
      }
    }
    if (currentSentence.length) {
      sentences.push(currentSentence);
    }
    return sentences;
  }
  /**
   * Notifies listeners of updates to the transcript
   * Dispatches a CustomEvent with the current transcript groups
   */
  notifyUpdate() {
    this.dispatchTypedEvent(
      "update",
      new TranscriptUpdateEvent(this.getTranscriptGroups())
    );
  }
}
function transcriptGroupKey(group) {
  return `${group.type}-${group.type === "agent" ? group.data[0].startTime : group.data[0].startTime}-${group.type === "speaker" ? group.speaker : "agent"}`;
}

function useFlowTranscript() {
  const [transcriptGroups, setTranscriptGroups] = react.useState(
    []
  );
  const { sessionId } = flowClientReact.useFlow();
  const transcriptManager = react.useMemo(() => new TranscriptManager(), []);
  react.useEffect(() => {
    if (sessionId) {
      transcriptManager.clearTranscripts();
    }
  }, [sessionId, transcriptManager]);
  react.useEffect(() => {
    const handleUpdate = (event) => {
      setTranscriptGroups(event.transcriptGroups);
    };
    transcriptManager.addEventListener("update", handleUpdate);
    return () => {
      transcriptManager.removeEventListener("update", handleUpdate);
    };
  }, [transcriptManager]);
  flowClientReact.useFlowEventListener("message", ({ data }) => {
    transcriptManager.handleMessage(data);
  });
  return transcriptGroups;
}

function wordsToText(words) {
  return words.reduce(
    (text, word) => `${text}${words.indexOf(word) > 0 && !word.punctuation ? " " : ""}${word.text}`,
    ""
  );
}

exports.TranscriptManager = TranscriptManager;
exports.TranscriptUpdateEvent = TranscriptUpdateEvent;
exports.transcriptGroupKey = transcriptGroupKey;
exports.useFlowTranscript = useFlowTranscript;
exports.wordsToText = wordsToText;
//# sourceMappingURL=index.cjs.map
