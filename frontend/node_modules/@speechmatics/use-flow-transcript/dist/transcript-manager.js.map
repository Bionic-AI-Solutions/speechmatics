{"version":3,"file":"transcript-manager.js","sources":["../src/transcript-manager.ts"],"sourcesContent":["import type {\n  AddPartialTranscriptMessage,\n  AddTranscriptMessage,\n  FlowClientIncomingMessage,\n  ResponseCompletedMessage,\n  ResponseInterruptedMessage,\n  ResponseStartedMessage,\n} from '@speechmatics/flow-client-react';\nimport { TypedEventTarget } from 'typescript-event-target';\nimport {\n  type TranscriptUpdateMessage,\n  type Word,\n  type AgentResponse,\n  type TranscriptGroup,\n  type TranscriptManagerEvents,\n  TranscriptUpdateEvent,\n} from './types';\n\n/**\n * Manages the state and processing of a real-time transcript\n * Handles both human speech transcription and AI agent responses\n * Uses EventTarget to notify listeners of updates\n *\n * Example usage:\n * ```ts\n * const transcriptManager = new TranscriptManager();\n *\n * // Listen for updates\n * transcriptManager.addEventListener('update', (event: TranscriptUpdateEvent) => {\n *   const transcriptGroups = event.transcriptGroups;\n *   // Handle updated transcript groups\n * });\n *\n * // Process incoming messages\n * transcriptManager.handleMessage({\n *   message: 'AddTranscript',\n *   results: [\n *     // message data\n *   ]\n * });\n */\nexport class TranscriptManager extends TypedEventTarget<TranscriptManagerEvents> {\n  // Store final transcribed words\n  private finals: Word[] = [];\n  // Store partial (in-progress) transcribed words\n  private partials: Word[] = [];\n  // Store AI agent responses\n  private agentResponses: AgentResponse[] = [];\n\n  /**\n   * Clears all transcript data and notifies listeners\n   */\n  public clearTranscripts(): void {\n    this.finals = [];\n    this.partials = [];\n    this.agentResponses = [];\n    this.notifyUpdate();\n  }\n\n  /**\n   * Main entry point for processing incoming messages\n   * Routes different message types to their appropriate handlers\n   */\n  handleMessage(message: FlowClientIncomingMessage) {\n    // Only process messages we care about\n    switch (message.message) {\n      case 'AddPartialTranscript':\n      case 'AddTranscript':\n      case 'ResponseStarted':\n      case 'ResponseCompleted':\n      case 'ResponseInterrupted':\n        this.processMessage(message);\n        break;\n      // Ignore other message types\n      default:\n        return;\n    }\n  }\n\n  private processMessage(message: TranscriptUpdateMessage) {\n    switch (message.message) {\n      case 'AddPartialTranscript':\n        this.handlePartialTranscript(message);\n        break;\n      case 'AddTranscript':\n        this.handleTranscript(message);\n        break;\n      case 'ResponseStarted':\n        this.handleAgentResponseStart(message);\n        break;\n      case 'ResponseCompleted':\n      case 'ResponseInterrupted':\n        this.handleAgentResponseEnd(message);\n        break;\n    }\n  }\n\n  /**\n   * Processes partial transcripts (in-progress speech)\n   * These are temporary and will be replaced by final transcripts\n   */\n  private handlePartialTranscript(message: AddPartialTranscriptMessage) {\n    if (!message.results?.length) return;\n    this.partials = this.getWords(message);\n    this.notifyUpdate();\n  }\n\n  /**\n   * Processes final transcripts\n   * Also handles cleanup of related partial transcripts\n   */\n  private handleTranscript(message: AddTranscriptMessage) {\n    if (!message.results?.length) return;\n    const incomingWords = this.getWords(message);\n    this.finals = [...this.finals, ...incomingWords];\n\n    // Remove any partial transcripts that have been finalized\n    const resultsEndAt = incomingWords[incomingWords.length - 1].endTime;\n    this.partials = this.partials.filter(\n      (p) => p.startTime >= resultsEndAt && p.endTime > resultsEndAt,\n    );\n\n    // Special handling for end-of-sentence punctuation\n    if (\n      this.partials.length &&\n      message.results[0].is_eos &&\n      this.partials[0].punctuation &&\n      this.partials[0].eos\n    ) {\n      this.partials.shift();\n    }\n\n    this.notifyUpdate();\n  }\n\n  /**\n   * Handles the start of an AI agent response\n   * Creates a new agent response entry with start time\n   */\n  private handleAgentResponseStart(message: ResponseStartedMessage) {\n    if (!message.content || !message.start_time) return;\n\n    this.agentResponses.push({\n      speaker: 'agent',\n      agent: true,\n      startTime: message.start_time,\n      text: message.content,\n    });\n\n    this.notifyUpdate();\n  }\n\n  /**\n   * Handles the completion or interruption of an AI agent response\n   * Updates the existing response or creates a new one if not found\n   */\n  private handleAgentResponseEnd(\n    message: ResponseCompletedMessage | ResponseInterruptedMessage,\n  ) {\n    if (!message.content || !message.start_time || !message.end_time) return;\n\n    const existingIndex = this.agentResponses.findIndex(\n      (r) => r.startTime === message.start_time,\n    );\n\n    const updatedResponse = {\n      speaker: 'agent' as const,\n      agent: true as const,\n      startTime: message.start_time,\n      endTime: message.end_time,\n      text: message.content,\n    };\n\n    if (existingIndex !== -1) {\n      this.agentResponses[existingIndex] = updatedResponse;\n    } else {\n      this.agentResponses.push(updatedResponse);\n    }\n\n    this.notifyUpdate();\n  }\n\n  /**\n   * Converts raw message results into Word objects\n   * Handles both regular words and punctuation\n   */\n  private getWords(\n    message: Exclude<\n      TranscriptUpdateMessage,\n      | ResponseStartedMessage\n      | ResponseCompletedMessage\n      | ResponseInterruptedMessage\n    >,\n  ): Word[] {\n    if (!message.results) return [];\n\n    return message.results.map((r) => {\n      const word = {\n        startTime: r.start_time,\n        endTime: r.end_time,\n        text: r.alternatives?.[0]?.content ?? '',\n        speaker: r.alternatives?.[0]?.speaker ?? 'UU', // UU = Unknown User\n        partial: message.message === 'AddPartialTranscript',\n      };\n\n      if (r.type === 'punctuation') {\n        return {\n          ...word,\n          punctuation: true,\n          eos: r.is_eos ?? false,\n          attachesTo: r.attaches_to,\n        };\n      }\n      return { ...word, punctuation: false };\n    });\n  }\n\n  /**\n   * Generates the current state of the transcript\n   * Groups words and responses by speaker and chronological order\n   */\n  getTranscriptGroups(): TranscriptGroup[] {\n    const sentences = this.getSentences();\n    const sentencesAndResponses = [...sentences, ...this.agentResponses];\n\n    // Sort everything by start time\n    sentencesAndResponses.sort((a, b) => {\n      const startTimeA = 'agent' in a ? a.startTime : a[0].startTime;\n      const startTimeB = 'agent' in b ? b.startTime : b[0].startTime;\n      return startTimeA - startTimeB;\n    });\n\n    const allSorted = sentencesAndResponses.flat();\n    const groups: TranscriptGroup[] = [];\n    let currentGroup: TranscriptGroup | undefined;\n\n    // Group consecutive items from the same speaker together\n    for (const wordOrResponse of allSorted) {\n      if (!currentGroup) {\n        currentGroup =\n          'agent' in wordOrResponse\n            ? {\n                type: 'agent',\n                data: [wordOrResponse],\n              }\n            : {\n                type: 'speaker',\n                data: [wordOrResponse],\n                speaker: wordOrResponse.speaker,\n              };\n        continue;\n      }\n\n      if (currentGroup.type === 'agent' && 'agent' in wordOrResponse) {\n        currentGroup.data.push(wordOrResponse);\n      } else if (\n        currentGroup.type === 'speaker' &&\n        !('agent' in wordOrResponse) &&\n        wordOrResponse.speaker === currentGroup.speaker\n      ) {\n        currentGroup.data.push(wordOrResponse);\n      } else {\n        groups.push(currentGroup);\n        currentGroup =\n          'agent' in wordOrResponse\n            ? { type: 'agent', data: [wordOrResponse] }\n            : {\n                type: 'speaker',\n                data: [wordOrResponse],\n                speaker: wordOrResponse.speaker,\n              };\n      }\n    }\n\n    if (currentGroup) {\n      groups.push(currentGroup);\n    }\n\n    return groups;\n  }\n\n  /**\n   * Groups words into sentences based on punctuation and end-of-sentence markers\n   */\n  private getSentences(): Word[][] {\n    const sentences: Word[][] = [];\n    let currentSentence: Word[] = [];\n\n    for (const word of [...this.finals, ...this.partials]) {\n      currentSentence.push(word);\n      if (word.punctuation && word.eos) {\n        sentences.push(currentSentence);\n        currentSentence = [];\n      }\n    }\n\n    if (currentSentence.length) {\n      sentences.push(currentSentence);\n    }\n\n    return sentences;\n  }\n\n  /**\n   * Notifies listeners of updates to the transcript\n   * Dispatches a CustomEvent with the current transcript groups\n   */\n  private notifyUpdate() {\n    this.dispatchTypedEvent(\n      'update',\n      new TranscriptUpdateEvent(this.getTranscriptGroups()),\n    );\n  }\n}\n\nexport function transcriptGroupKey(group: TranscriptGroup): string {\n  return `${group.type}-${\n    group.type === 'agent' ? group.data[0].startTime : group.data[0].startTime\n  }-${group.type === 'speaker' ? group.speaker : 'agent'}`;\n}\n\nexport default TranscriptManager;\n"],"names":[],"mappings":";;;;;;;AAyCO;AAA0E;AAA1E;AAEL;AAAA;AAEA;AAAA;AAEA;AAAA;AAA2C;AAAA;AAAA;AAAA;AAAA;AAMzC;AACA;AACA;AACA;AAAkB;AACpB;AAAA;AAAA;AAAA;AAAA;AAQE;AAAyB;AAClB;AACA;AACA;AACA;AAEH;AACA;AAAA;AAAA;AAGA;AAAA;AACJ;AACF;AAGE;AAAyB;AAErB;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AACG;AAEH;AACA;AAAA;AACJ;AACF;AAAA;AAAA;AAAA;AAAA;AAOE;AACA;AACA;AAAkB;AACpB;AAAA;AAAA;AAAA;AAAA;AAOE;AACA;AACA;AAGA;AACA;AAA8B;AACsB;AAIpD;AAME;AAAoB;AAGtB;AAAkB;AACpB;AAAA;AAAA;AAAA;AAAA;AAOE;AAEA;AAAyB;AACd;AACF;AACY;AACL;AAGhB;AAAkB;AACpB;AAAA;AAAA;AAAA;AAAA;AASE;AAEA;AAA0C;AACT;AAGjC;AAAwB;AACb;AACF;AACY;AACF;AACH;AAGhB;AACE;AAAqC;AAErC;AAAwC;AAG1C;AAAkB;AACpB;AAAA;AAAA;AAAA;AAAA;AAcE;AAEA;AACE;AAAa;AACE;AACF;AAC2B;AACG;AAAA;AACZ;AAG/B;AACE;AAAO;AACF;AACU;AACI;AACH;AAChB;AAEF;AAAqC;AACtC;AACH;AAAA;AAAA;AAAA;AAAA;AAOE;AACA;AAGA;AACE;AACA;AACA;AAAoB;AAGtB;AACA;AACA;AAGA;AACE;AACE;AAEM;AACQ;AACe;AAEvB;AACQ;AACe;AACG;AAEhC;AAAA;AAGF;AACE;AAAqC;AAMrC;AAAqC;AAErC;AACA;AAGM;AACQ;AACe;AACG;AAC1B;AACR;AAGF;AACE;AAAwB;AAG1B;AAAO;AACT;AAAA;AAAA;AAAA;AAME;AACA;AAEA;AACE;AACA;AACE;AACA;AAAmB;AACrB;AAGF;AACE;AAA8B;AAGhC;AAAO;AACT;AAAA;AAAA;AAAA;AAAA;AAOE;AAAK;AACH;AACoD;AACtD;AAEJ;AAEO;AACL;AAGF;;"}